# include <Rcpp.h>
# include "ggt.h"

using namespace Rcpp;
using namespace std;

/**
 * get_hdp() constructs an ordered optimal group design for the hierarchical 
 * generalized group testing problem using dynamic programming.
 *
 * @param q (Rcpp::NumericVector): ordered vector of individual prevalences.
 * @param Se (double): assay sensitivity.
 * @param Sp (double): assay specificity.
 *
 * @return Rcpp::List with elements:
 *          h (Rcpp::NumericMatrix): element ij is expected number of tests for
 *                                   defective group comprised of ordered 
 *                                   population members i to j.
 *          d (Rcpp::NumericMatrix): element ij is next stage group size for
 *                                   defective group comprised of ordered 
 *                                   population members i to j.
 *          H (Rcpp::NumericVector): expected number of tests for binomial case.
 *          D (Rcpp::NumericVector): optimal partition sizes for binomial case.
 */
List get_hdp(NumericVector q, double Se, double Sp)
{
    int N = q.size();
    int n = N - 2;
    double tmp1, tmp2, tmp3, tmp4;
    double prodI;
    double prodII;
    double prodIII;
    double prob1, prob2, prob3;
    int f, g;

    NumericMatrix h(N);      // Matrix to store expected number of tests for h
    NumericMatrix d(N);      // Matrix to store design for positive groups
    NumericVector H(N + 1);  // Vector to store expected number of tests for H
    NumericVector D(N);      // Vector to store design for binomial groups
    NumericMatrix pi_mat(N); // Matrix to store q products

    H(N - 1) = 1;
    D(N - 1) = 1;

    // Populate pi_mat
    for (int i = 0; i < N; i++) {
        for (int j = i; j < N; j++) {
                pi_mat(i, j) = 1;
                for (int k = i; k < j + 1; k++) {
                    pi_mat(i, j) *= q[k];                 
                }
        }
    }

    // Dynamic programming algorithm
    for (int i = 0; i < N - 1; i++) {
        tmp3 = H(n + 1) + (Se * (1 - q(n)) + (1 - Sp) * q(n)) * h(n, n);
        g = 1;
        
        for (int j = 1; j < i + 2; j++) {
            prodI = pi_mat(n, n + j);
            prob1 = Se * (1 - prodI) + (1 - Sp) * prodI;
            for (int k = 0; k < j; k++) {
                prodII = pi_mat(n, n + k);
                prob2 = Se * (1 - prodII) + (1 - Sp) * prodII;
                prodIII = pi_mat(n + k + 1, n + j);
                prob3 = Se * (1 - prodIII) + (1 - Sp) * prodIII;
                tmp2 = -(1 - prob2) * (prob3) / (prob1) + 
                        (prob2) / (prob1) * h(n, n + k) + 
                        (prob3) / (prob1) * h(n + k + 1, n + j);
                if (k == 0) {
                    tmp1 = tmp2;
                    f = 1;
                } else if (tmp1 > tmp2) {
                    tmp1 = tmp2;
                    f = k + 1;
                }
            }
                h(n, n + j) = 2 + tmp1;
                d(n, n + j) = f;

                tmp4 = H(n + j + 1) + (1 - prodI) * h(n, n + j);

                tmp4 = H(n + j + 1) + prob1 * h(n, n + j);

                if (tmp3 > tmp4) {
                    tmp3 = tmp4;
                    g = j + 1;
                }
        }

        H(n) = 1 + tmp3;
        D(n) = g;

        n--;
    }

       return List::create(h, d, H, D);
}

/**
 * get_labels() creates initial group labels for optimal paritions.
 *
 * @param D (Rcpp::NumericVector): vector of partition sizes generated by
 *                                 get_hdp().
 *
 * @return (Rcpp::NumericVector): vector of labels for ordered population.
 */
NumericVector get_labels(NumericVector D) 
{
    int N = D.size();
    int i = 0;
    int j = 1;

    while(i < N) {
      int tmp = D(i);
      for (int k = 0; k < tmp; k++) {
        D(i + k) = j;
      }

      i += tmp;
      j += 1;
    }

    return D;
}
