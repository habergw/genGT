# include <Rcpp.h>
# include "ggt.h"

using namespace Rcpp;
using namespace std;

// Returns probability of test being positive with
// given misclassification rates.
double get_prob(double prod_val, double Se, double Sp)
{
  return Se * (1 - prod_val) + (1 - Sp) * prod_val;
}

/**
 * get_hdp() constructs an ordered optimal group design for the hierarchical 
 * generalized group testing problem using dynamic programming.
 *
 * @param q (Rcpp::NumericVector): ordered vector of individual prevalences.
 * @param Se (double): assay sensitivity.
 * @param Sp (double): assay specificity.
 *
 * @return Rcpp::List with elements:
 *          h (Rcpp::NumericMatrix): element ij is expected number of tests for
 *                                   defective group comprised of ordered 
 *                                   population members i to j.
 *          d (Rcpp::NumericMatrix): element ij is next stage group size for
 *                                   defective group comprised of ordered 
 *                                   population members i to j.
 *          H (Rcpp::NumericVector): expected number of tests for binomial case.
 *          D (Rcpp::NumericVector): optimal partition sizes for binomial case.
 */
List get_hdp(NumericVector q, double Se, double Sp)
{
    int N = q.size();
    double T_0, T_10, T_11, P_0, P_10, P_11;
    double prod_a, prod_b, prod_ab;
    double tmp1, tmp2;

    NumericMatrix h(N);      // Matrix to store expected number of tests for h
    NumericMatrix d(N);      // Matrix to store design for positive groups
    NumericVector H(N + 1);  // Vector to store expected number of tests for H
    NumericVector D(N);      // Vector to store design for binomial groups
    NumericMatrix pi_mat(N); // Matrix to store q products

    H(N - 1) = 1;
    D(N - 1) = 1;

    // Populate pi_mat
    for (int i = 0; i < N; i++) {
        for (int j = i; j < N; j++) {
                pi_mat(i, j) = 1;
                for (int k = i; k < j + 1; k++) {
                    pi_mat(i, j) *= q[k];                 
                }
        }
    }

    // Dynamic programming algorithm
    for (int n = N - 2; n >= 0; n--) {
      H(n) = 1 + H(n + 1) + get_prob(pi_mat(n, n), Se, Sp) * h(n, n);
      D(n) = 1;

        for (int k = 1; k < N - n; k++) {
          for (int x = 0; x < k; x++) {
            T_0 = 1 + h(n + x + 1, n + k);
            T_10 = 2 + h(n, n + x);
            T_11 = 2 + h(n, n + x) + h(n + x + 1, n + k);
            prod_a = pi_mat(n, n + x);
            prod_b = pi_mat(n + x + 1, n + k);
            prod_ab = pi_mat(n, n + k);
            P_0 = Se * (1 - Se) + prod_a *
                   (Sp * Se - Se * (1 - Se)) +
              prod_ab * Sp * (1 - Sp - Se);
            P_10 = Se * Se * (1 - Se) + prod_a *
                    Se * (1 - Se) * (1 - Se - Sp) +
                     prod_b * Se * Se * (Sp + Se - 1) +
              prod_ab * (Se * (1 - Se) * (Se + Sp - 1) +
                                          Sp * (1 - Sp) * (1 - Sp) - Se * Se * Sp);
            P_11 = Se * Se * Se + prod_a * Se * Se * (1 - Sp - Se) +
              prod_b * Se * Se * (1 - Se - Sp) +
              prod_ab * (pow(1 - Sp, 3) - 2 * Se * Se * (1 - Sp) +
                                          pow(Se, 3));

            tmp1 = T_0 * P_0 + T_10 * P_10 + T_11 * P_11;
            
            tmp1 /= get_prob(pi_mat(n, n + k), Se, Sp);
            if (x == 0) {
              h(n, n + k) = tmp1;
              d(n, n + k) = x + 1;
            } else if (tmp1 < h(n, n + k)) {
              h(n, n + k) = tmp1;
              d(n, n + k) = x + 1;
            }
          }
          tmp2 = 1 + H(n + k + 1) + get_prob(pi_mat(n, n + k), Se, Sp) *
            h(n, n + k);

          if (tmp2 < H(n)) {
            H(n) = tmp2;
            D(n) = k + 1;
          }
        }
    }

            return List::create(h, d, H, D);
}

/**
 * get_labels() creates initial group labels for optimal partitions.
 *
 * @param D (Rcpp::NumericVector): vector of partition sizes generated by
 *                                 get_hdp().
 *
 * @return (Rcpp::NumericVector): vector of labels for ordered population.
 */
NumericVector get_labels(NumericVector D) 
{
    int N = D.size();
    int i = 0;
    int j = 1;

    while(i < N) {
      int tmp = D(i);
      for (int k = 0; k < tmp; k++) {
        D(i + k) = j;
      }

      i += tmp;
      j += 1;
    }

    return D;
}
